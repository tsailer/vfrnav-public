/*****************************************************************************/

/*
 *      genfascrc.cc  --  Generate Final Approach Segment CRC Table.
 *
 *      Copyright (C) 2012  Thomas Sailer (t.sailer@alumni.ethz.ch)
 *
 *      This program is free software; you can redistribute it and/or modify
 *      it under the terms of the GNU General Public License as published by
 *      the Free Software Foundation; either version 2 of the License, or
 *      (at your option) any later version.
 *
 *      This program is distributed in the hope that it will be useful,
 *      but WITHOUT ANY WARRANTY; without even the implied warranty of
 *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *      GNU General Public License for more details.
 *
 *      You should have received a copy of the GNU General Public License
 *      along with this program; if not, write to the Free Software
 *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 */

/*****************************************************************************/

#include "dbobj.h"
#include <iostream>
#include <iomanip>

class CRC
{
public:
	typedef DbBaseElements::Airport::FinalApproachSegment::fas_datablock_t fas_datablock_t;

	CRC(void);
	uint32_t crc(const uint8_t *data, unsigned int length, uint32_t initial = 0U);
	uint32_t crc1(const uint8_t *data, unsigned int length, uint32_t initial = 0U);
	uint32_t crc2(const uint8_t *data, unsigned int length, uint32_t initial = 0U);
	std::ostream& print(std::ostream& os) const;
	bool check(const fas_datablock_t data);
	static uint8_t rev8(uint8_t w);
	static uint32_t rev32(uint32_t w);

protected:
	uint32_t m_table[256];
};

CRC::CRC(void)
{
	for (unsigned int i = 0; i < sizeof(m_table) / sizeof(m_table[0]); ++i) {
		uint32_t crc(i);
		for (unsigned int j = 0; j < 8; ++j) {
			uint32_t b(crc & 1);
			crc >>= 1;
			if (b)
				crc ^= AirportsDb::Airport::FinalApproachSegment::crc_rev_poly;
		}
		m_table[i] = crc;
	}
}

uint8_t CRC::rev8(uint8_t w)
{
        w = ((w >> 4) & 0x0f) | ((w << 4) & 0xf0);
        w = ((w >> 2) & 0x33) | ((w << 2) & 0xcc);
        w = ((w >> 1) & 0x55) | ((w << 1) & 0xaa);
        return w;
}

uint32_t CRC::rev32(uint32_t w)
{
        w = ((w >> 16) & 0x0000ffff) | ((w << 16) & 0xffff0000);
        w = ((w >> 8) & 0x00ff00ff) | ((w << 8) & 0xff00ff00);
        w = ((w >> 4) & 0x0f0f0f0f) | ((w << 4) & 0xf0f0f0f0);
        w = ((w >> 2) & 0x33333333) | ((w << 2) & 0xcccccccc);
        w = ((w >> 1) & 0x55555555) | ((w << 1) & 0xaaaaaaaa);
        return w;
}

uint32_t CRC::crc(const uint8_t *data, unsigned int length, uint32_t initial)
{
	for (; length > 0; --length, ++data) {
		uint8_t b(initial ^ *data);
		initial >>= 8;
		initial ^= m_table[b];
	}
	return initial;
}

uint32_t CRC::crc1(const uint8_t *data, unsigned int length, uint32_t initial)
{
	for (; length > 0; --length, ++data) {
		uint8_t b(*data);
		for (unsigned int i = 0; i < 8; ++i, b >>= 1) {
			uint8_t bb((b ^ (initial >> 31)) & 1);
			initial <<= 1;
			if (bb)
				initial ^= AirportsDb::Airport::FinalApproachSegment::crc_poly;
		}
	}
	return initial;
}

uint32_t CRC::crc2(const uint8_t *data, unsigned int length, uint32_t initial)
{
	for (; length > 0; --length, ++data) {
		uint8_t b(*data);
		for (unsigned int i = 0; i < 8; ++i, b >>= 1) {
			uint8_t bb((b ^ initial) & 1);
			initial >>= 1;
			if (bb)
				initial ^= AirportsDb::Airport::FinalApproachSegment::crc_rev_poly;
		}
	}
	return initial;
}

std::ostream& CRC::print(std::ostream& os) const
{
	os << "// do not edit, automatically generated by genfascrc.cc" << std::endl << std::endl
	   << "#include \"dbobj.h\"" << std::endl << std::endl
	   << "const uint32_t DbBaseElements::Airport::FinalApproachSegment::crc_table[" << (sizeof(m_table) / sizeof(m_table[0])) << "] = {";
	for (unsigned int i = 0; i < sizeof(m_table) / sizeof(m_table[0]); ++i) {
		if (i)
			os << ", ";
		if (!(i & 7))
			os << std::endl << '\t';
		{
			std::ostringstream oss;
			oss << std::hex << std::setw(8) << std::setfill('0') << m_table[i];
			os << "0x" << oss.str();
		}
	}
	return os << std::endl << "};" << std::endl;
}

bool CRC::check(const fas_datablock_t data)
{
	uint32_t ccrc(crc(data, sizeof(fas_datablock_t)/sizeof(data[0]) - 4));
	uint32_t ckcrc(crc(data, sizeof(fas_datablock_t)/sizeof(data[0])));
	uint32_t dcrc(0);
	for (unsigned int i = sizeof(fas_datablock_t)/sizeof(data[0]) - 4; i < sizeof(fas_datablock_t)/sizeof(data[0]); ++i)
		dcrc = (dcrc >> 8) | (data[i] << 24);
	if (ccrc != dcrc || ckcrc) {
		std::ostringstream oss;
		oss << "Computed CRC: 0x" << std::hex << std::setw(8) << std::setfill('0') << ccrc
		    << " inv: 0x" << std::setw(8) << std::setfill('0') << (~ccrc)
		    << " rev: 0x" << std::setw(8) << std::setfill('0') << rev32(ccrc)
		    << " rev,inv: 0x" << std::setw(8) << std::setfill('0') << rev32(~ccrc)
		    << " Expected CRC: 0x" << std::setw(8) << std::setfill('0') << dcrc
		    << " CRC Check: 0x" << std::setw(8) << std::setfill('0') << ckcrc;
		std::cerr << oss.str() << std::endl
			  << "Datablock Size: " << sizeof(fas_datablock_t) << " Element Size: " << sizeof(data[0]) << std::endl;
	}
	return ccrc == dcrc && !ckcrc;
}

int main(int argc, char *argv[])
{
	CRC crc;
	crc.print(std::cout);
	static const CRC::fas_datablock_t data = {
		0x10, 0x03, 0x07, 0x13, 0x0C, 0x18, 0x00, 0x00, 0x01, 0x34, 0x32,
		0x05, 0xD8, 0x10, 0x35, 0x14, 0x60, 0xDA, 0xEA, 0x02, 0xBE, 0x3D,
		0xA0, 0x05, 0xFF, 0x5C, 0x02, 0xFE, 0x2C, 0x81, 0x5E, 0x01, 0x64,
		0x5C, 0xC8, 0xFA, 0x1D, 0x00, 0xD4, 0x3F
	};
	return crc.check(data) ? 0 : 1;
}















