/*****************************************************************************/

/*
 *      genmodescrc.cc  --  Generate Mode-S Transponder CRC Table.
 *
 *      Copyright (C) 2013  Thomas Sailer (t.sailer@alumni.ethz.ch)
 *
 *      This program is free software; you can redistribute it and/or modify
 *      it under the terms of the GNU General Public License as published by
 *      the Free Software Foundation; either version 2 of the License, or
 *      (at your option) any later version.
 *
 *      This program is distributed in the hope that it will be useful,
 *      but WITHOUT ANY WARRANTY; without even the implied warranty of
 *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *      GNU General Public License for more details.
 *
 *      You should have received a copy of the GNU General Public License
 *      along with this program; if not, write to the Free Software
 *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 */

/*****************************************************************************/

#include "modes.h"
#include <iostream>
#include <iomanip>

class CRC
{
public:
	CRC(void);
	uint32_t crc(const uint8_t *data, unsigned int length, uint32_t initial = 0U);
	std::ostream& print(std::ostream& os) const;
	bool check(const uint8_t *data, unsigned int dlen);

protected:
	uint32_t m_table[256];
	uint32_t m_revtable[256];
	typedef std::map<uint32_t,uint16_t> errtable_t;
	errtable_t m_err56;
	errtable_t m_err112;
	double m_nltable[4 * ModeSMessage::NZ - 1];
};

CRC::CRC(void)
{
	for (unsigned int i = 0; i < sizeof(m_table) / sizeof(m_table[0]); ++i) {
		uint32_t crc(i);
		crc <<= 16;
		for (unsigned int j = 0; j < 8; ++j) {
			crc <<= 1;
			if (crc & (1U << 24))
				crc ^= ModeSMessage::crc_poly;
		}
		m_table[i] = crc;
	}
	for (unsigned int i = 0; i < sizeof(m_revtable) / sizeof(m_revtable[0]); ++i) {
		uint32_t crc(i);
		for (unsigned int j = 0; j < 8; ++j) {
			if (crc & 1)
				crc ^= ModeSMessage::crc_poly;
			crc >>= 1;
		}
		m_revtable[i] = crc;
	}
	{
		uint8_t pkt[7];
		memset(pkt, 0, sizeof(pkt));
		for (unsigned int i = 0; i < 8 * sizeof(pkt); ++i) {
			pkt[i >> 3] ^= (1 << (i & 7));
			uint32_t c(crc(pkt, sizeof(pkt), 0U));
			if (m_err56.find(c) != m_err56.end())
				std::cerr << "Duplicate syndrome " << c << std::endl;
			m_err56[c] = 0xff00 | i;
			for (unsigned int j = i + 1; j < 8 * sizeof(pkt); ++j) {
				pkt[j >> 3] ^= (1 << (j & 7));
				uint32_t c(crc(pkt, sizeof(pkt), 0U));
				pkt[j >> 3] ^= (1 << (j & 7));
				if (m_err56.find(c) != m_err56.end()) {
					std::cerr << "Duplicate syndrome " << c << std::endl;
					continue;
				}
				m_err56[c] = (((uint16_t)j) << 8) | i;
			}
			pkt[i >> 3] ^= (1 << (i & 7));
		}
	}
	{
		uint8_t pkt[14];
		memset(pkt, 0, sizeof(pkt));
		for (unsigned int i = 0; i < 8 * sizeof(pkt); ++i) {
			pkt[i >> 3] ^= (1 << (i & 7));
			uint32_t c(crc(pkt, sizeof(pkt), 0U));
			if (m_err112.find(c) != m_err112.end())
				std::cerr << "Duplicate syndrome " << c << std::endl;
			m_err112[c] = 0xff00 | i;
			for (unsigned int j = i + 1; j < 8 * sizeof(pkt); ++j) {
				pkt[j >> 3] ^= (1 << (j & 7));
				uint32_t c(crc(pkt, sizeof(pkt), 0U));
				pkt[j >> 3] ^= (1 << (j & 7));
				if (m_err112.find(c) != m_err112.end()) {
					std::cerr << "Duplicate syndrome " << c << std::endl;
					continue;
				}
				m_err112[c] = (((uint16_t)j) << 8) | i;
			}
			pkt[i >> 3] ^= (1 << (i & 7));
		}
	}
	{
		double c(1-cos(M_PI * 0.5 / ModeSMessage::NZ));
		for (unsigned int i = 2; i < 4 * ModeSMessage::NZ; ++i)
			m_nltable[i - 2] = acos(sqrt(c / (1 - cos(M_PI * 2.0 / i))));
	}
	m_nltable[4 * ModeSMessage::NZ - 2] = -std::numeric_limits<double>::max();
}

uint32_t CRC::crc(const uint8_t *data, unsigned int length, uint32_t initial)
{
	for (; length > 0; --length, ++data) {
		uint8_t b((initial >> 16) ^ *data);
		initial <<= 8;
		initial ^= m_table[b];
		initial &= 0xffffff;
	}
	return initial;
}

std::ostream& CRC::print(std::ostream& os) const
{
	os << "// do not edit, automatically generated by genmodescrc.cc" << std::endl << std::endl
	   << "#include \"modes.h\"" << std::endl << std::endl
	   << "const uint32_t ModeSMessage::crc_table[" << (sizeof(m_table) / sizeof(m_table[0])) << "] = {";
	for (unsigned int i = 0; i < sizeof(m_table) / sizeof(m_table[0]); ++i) {
		if (i)
			os << ", ";
		if (!(i & 7))
			os << std::endl << '\t';
		{
			std::ostringstream oss;
			oss << std::hex << std::setw(6) << std::setfill('0') << m_table[i];
			os << "0x" << oss.str();
		}
	}
	os << std::endl << "};" << std::endl << std::endl
	   << "const uint32_t ModeSMessage::rev_crc_table[" << (sizeof(m_revtable) / sizeof(m_revtable[0])) << "] = {";
	for (unsigned int i = 0; i < sizeof(m_revtable) / sizeof(m_revtable[0]); ++i) {
		if (i)
			os << ", ";
		if (!(i & 7))
			os << std::endl << '\t';
		{
			std::ostringstream oss;
			oss << std::hex << std::setw(6) << std::setfill('0') << m_revtable[i];
			os << "0x" << oss.str();
		}
	}
#if 0
	// not needed, it's a subset of the 112 bit message table (just subtract 56 from the bits)
	os << std::endl << "};" << std::endl << std::endl
	   << "const uint32_t ModeSMessage::msg56_crc_residue[" << m_err56.size() << "] = {";
	{
		unsigned int n(0);
		for (errtable_t::const_iterator i(m_err56.begin()), e(m_err56.end()); i != e; ++i, ++n) {
			if (n)
				os << ", ";
			if (!(n & 7))
				os << std::endl << '\t';
			{
				std::ostringstream oss;
				oss << std::hex << std::setw(6) << std::setfill('0') << i->first;
				os << "0x" << oss.str();
			}
		}
	}
	os << std::endl << "};" << std::endl << std::endl
	   << "const uint8_t ModeSMessage::msg56_crc_errloc[" << m_err56.size() << "][2] = {";
	{
		unsigned int n(0);
		for (errtable_t::const_iterator i(m_err56.begin()), e(m_err56.end()); i != e; ++i, ++n) {
			if (n)
				os << ", ";
			if (!(n & 7))
				os << std::endl << '\t';
			os << "{ " << (i->second & 0xff) << ", " << ((i->second >> 8) & 0xff) << " }";
		}
	}
#endif
	os << std::endl << "};" << std::endl << std::endl
	   << "const uint32_t ModeSMessage::msg112_crc_residue[" << m_err112.size() << "] = {";
	{
		unsigned int n(0);
		for (errtable_t::const_iterator i(m_err112.begin()), e(m_err112.end()); i != e; ++i, ++n) {
			if (n)
				os << ", ";
			if (!(n & 7))
				os << std::endl << '\t';
			{
				std::ostringstream oss;
				oss << std::hex << std::setw(6) << std::setfill('0') << i->first;
				os << "0x" << oss.str();
			}
		}
	}
	os << std::endl << "};" << std::endl << std::endl
	   << "const uint8_t ModeSMessage::msg112_crc_errloc[" << m_err112.size() << "][2] = {";
	{
		unsigned int n(0);
		for (errtable_t::const_iterator i(m_err112.begin()), e(m_err112.end()); i != e; ++i, ++n) {
			if (n)
				os << ", ";
			if (!(n & 7))
				os << std::endl << '\t';
			os << "{ " << (i->second & 0xff) << ", " << ((i->second >> 8) & 0xff) << " }";
		}
	}
	os << std::endl << "};" << std::endl << std::endl
	   << "const double ModeSMessage::NLtable[" << (sizeof(m_nltable) / sizeof(m_nltable[0])) << "] = {";
	for (unsigned int i = 0; i < sizeof(m_nltable) / sizeof(m_nltable[0]); ++i) {
		if (i)
			os << ", ";
		if (!(i & 3))
			os << std::endl << '\t';
		{
			std::ostringstream oss;
			oss << std::setprecision(20) << m_nltable[i];
			os << oss.str();
		}
	}
	return os << std::endl << "};" << std::endl;
}

bool CRC::check(const uint8_t *data, unsigned int dlen)
{
	if (dlen <= 3)
		return 0;
	uint32_t ccrc(crc(data, dlen-3));
	uint32_t ckcrc(crc(data, dlen));
	uint32_t dcrc(0);
	for (unsigned int i = dlen - 3; i < dlen; ++i)
		dcrc = (dcrc << 8) | data[i];
	if (ccrc != dcrc || ckcrc || true) {
		std::ostringstream oss;
		oss << "Computed CRC: 0x" << std::hex << std::setw(6) << std::setfill('0') << ccrc
		    << " Expected CRC: 0x" << std::setw(6) << std::setfill('0') << dcrc
		    << " CRC Check: 0x" << std::setw(6) << std::setfill('0') << ckcrc;
		std::cerr << oss.str() << std::endl
			  << "Datablock Size: " << dlen << std::endl;
	}
	return ccrc == dcrc && !ckcrc;
}

int main(int argc, char *argv[])
{
	CRC crc;
	crc.print(std::cout);
	static const uint8_t data1[] = {
		0x89, 0x0f, 0x5f, 0x22, 0x5c, 0xa0, 0xeb, 0xfe, 0xad, 0x5a, 0x76, 0xa4, 0xde, 0xd7
	};
	static const uint8_t data2[] = {
		//0x89, 0xca, 0x97, 0x1a, 0xbe, 0xa2, 0x3e, 0xd6, 0x92, 0xa1, 0x24, 0xb8, 0x99, 0x75
		0x8a, 0x7a, 0xce, 0x67, 0xe4, 0xa0, 0xac, 0x74, 0x13, 0x59, 0x6e, 0x01, 0xf5, 0x44
	};
	static const uint8_t data3[] = {
		0x5D, 0x3C, 0x66, 0x14, 0xC3, 0x15, 0xD2
	};
	static const uint8_t data4[] = {
		0x8F, 0x45, 0xAC, 0x52, 0x60, 0xBD, 0xF3, 0x48, 0x22, 0x2A, 0x58, 0xB9, 0x82, 0x84
	};
	bool ok(crc.check(data1, sizeof(data1)));
	ok = crc.check(data2, sizeof(data2)) && ok;
	ok = crc.check(data3, sizeof(data3)) /* && ok*/;
	ok = crc.check(data4, sizeof(data4)) && ok;
	return !ok;
}
