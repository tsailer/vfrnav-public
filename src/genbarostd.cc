/*****************************************************************************/

/*
 *      genbarostd.cc  --  Generate Standard Atmospheric Boundary Layers.
 *
 *      Copyright (C) 2012, 2016  Thomas Sailer (t.sailer@alumni.ethz.ch)
 *
 *      This program is free software; you can redistribute it and/or modify
 *      it under the terms of the GNU General Public License as published by
 *      the Free Software Foundation; either version 2 of the License, or
 *      (at your option) any later version.
 *
 *      This program is distributed in the hope that it will be useful,
 *      but WITHOUT ANY WARRANTY; without even the implied warranty of
 *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *      GNU General Public License for more details.
 *
 *      You should have received a copy of the GNU General Public License
 *      along with this program; if not, write to the Free Software
 *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 */

/*****************************************************************************/

#include "baro.h"
#include <sstream>
#include <iostream>
#include <iomanip>
#include <limits>

template<typename T>
class Atmosphere : public IcaoAtmosphere<T>
{
protected:
	static const char flttypname[];
public:
	typedef T float_t;
	static std::ostream& print_hdr(std::ostream& os);
	std::ostream& print(std::ostream& os) const;
	std::ostream& print_tbl(std::ostream& os, float_t alts = 0, float_t alte = 81000, float_t alti = 1000) const;
};

template<> const char Atmosphere<float>::flttypname[] = "float";
template<> const char Atmosphere<double>::flttypname[] = "double";

template<typename T>
std::ostream& Atmosphere<T>::print_hdr(std::ostream& os)
{
	return os << "// do not edit, automatically generated by genbarostd.cc" << std::endl << std::endl
		  << "#include \"baro.h\"" << std::endl;
}

template<typename T>
std::ostream& Atmosphere<T>::print(std::ostream& os) const
{
	os << std::endl
	   << "template<> const struct IcaoAtmosphere<" << flttypname
	   << ">::atmospheric_boundary IcaoAtmosphere<" << flttypname
	   << ">::stdbdry[nr_layers+1] = {";
	for (unsigned int i = 0; i <= this->nr_layers; ++i) {
		if (i)
			os << ',';
		std::ostringstream oss;
		oss << std::setprecision(10) << this->m_bdry[i].t
		    << ", " << this->m_bdry[i].p
		    << ", " << this->m_bdry[i].rho;
		os << std::endl << "\t{ " << oss.str() << " }";
	}
	return os << std::endl << "};" << std::endl;
}

template<typename T>
std::ostream& Atmosphere<T>::print_tbl(std::ostream& os, float_t alts, float_t alte, float_t alti) const
{
	os << std::endl
	   << "// Alt Press Temp Density AltP AltD" << std::endl;
	for (; alts <= alte; alts += alti) {
		float_t press, temp, altp, tempp, density, altd;
		this->altitude_to_pressure(&press, &temp, alts);
		this->pressure_to_altitude(&altp, &tempp, press);
		density = this->altitude_to_density(alts);
		altd = this->density_to_altitude(density);
		std::ostringstream oss;
		oss << std::fixed << alts << ' ' << press << ' ' << temp << ' ' << density << ' '
		    << altp << ' ' << altd;
		os << "// " << oss.str() << std::endl;
	}
	return os;
}

template<typename T>
std::ostream& operator<<(std::ostream& os, const Atmosphere<T>& atmo)
{
	return atmo.print(os);
}

template<> const struct IcaoAtmosphere<float>::atmospheric_boundary IcaoAtmosphere<float>::stdbdry[nr_layers+1] = {};
template<> const struct IcaoAtmosphere<double>::atmospheric_boundary IcaoAtmosphere<double>::stdbdry[nr_layers+1] = {};

int main(int argc, char *argv[])
{
	Atmosphere<float>::print_hdr(std::cout);
	{
		Atmosphere<float> atmo;
		std::cout << atmo;
		atmo.print_tbl(std::cout);
	}
	{
		Atmosphere<double> atmo;
		std::cout << atmo;
		atmo.print_tbl(std::cout);
	}
	return 0;
}
